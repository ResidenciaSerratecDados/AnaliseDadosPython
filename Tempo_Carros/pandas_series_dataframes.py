# -*- coding: utf-8 -*-
"""Pandas_Series_Dataframes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qcwefxGLiSuGbelgd07zklzxdZ-XjnNr

### Precisamos antes de tudo, importar a biblioteca. É um padrão abreviar o nome da biblioteca para 'pd' por meio de um alias.
"""

import pandas as pd

"""# Séries - Análise Unidimensional

### Uma série em pandas representa uma estrutura unidimensional, junto a um índice.

Vamos criar uma série números múltiplos de 10.
"""

serie = pd.Series([10, 20, 30, 40, 50, 60, 70, 80, 90])

"""Podemos usar os métodos Head e Tail para ler os primeiros e últimos elementos em uma série"""

serie.head()

serie.head(3)

serie.tail()

print(serie)

print(serie[3])

"""Em arquivos do tipo ipynb (notebooks), é possível utilizar também o método display para exibir os dados."""

display(serie)

"""Podemos acessar elementos da série através dos seus índices, assim como é feito nas listas."""

print(serie[3])

display(serie[4:7])

"""Podemos obter informações estatísticas básicas a partir da série."""

serie.describe()

"""Média Aritimética (Soma de todos elementos dividido pela quantidade de elementos)"""

tamanho = serie.size
print(f'Total de Elementos: {tamanho}')

media = serie.mean()
print(f'Média: {media}')

"""Maior Valor"""

maximo = serie.max()
print(f'Maior Valor: {maximo}')

"""Menor Valor"""

minimo = serie.min()
print(f'Menor Valor: {minimo}')

"""A Mediana, o elemento localizado no centro ao considerar a série ordenada em ordem crescente."""

mediana = serie.median()
print(f'Mediana: {mediana}')

"""Vamos adicionar mais um elemento no próximo índice da série"""

serie[9] = 100
print(serie)

"""Se a mediana é o elemento central, como calculá-la em um cojunto de elementos com número de itens par?"""

mediana = serie.median()
print(f'Mediana: {mediana}')

"""É possível realizar ações de filtragem na série"""

display(serie[serie > 30])

display(serie[serie % 3 == 0])

display(serie[serie > serie.mean()])

"""Podemos também, aplicar cálculos para todos os elementos das séries"""

serie_metade = serie/2

display(serie_metade)

"""E também fazer operações entre duas séries. Nesse caso, o índice é utilizado como referência para correlacionar os registros"""

display(serie + serie_metade)

"""Se o número de elementos for par, a mediana é a média aritmética dos dois valores centrais.

### Além dos índices numéricos autoincrementais, é possível fornecer um conjunto de índices customizado, que pode ser utilizado para acrescentar informações à análise.

Vamos criar uma série com as temperaturas médias por mês do ano em Petrópolis.

Fonte: https://www.climatempo.com.br/previsao-do-tempo/15-dias/cidade/317/petropolis-rj
"""

temperatura_minima = {'13/05': 13,
                     '14/05': 12,
                     '15/05': 15,
                     '16/05': 14,
                     '17/05': 14,
                     '18/05': 15,
                     '19/05': 14,
                     '20/05': 15,
                     '21/05': 16,
                     '22/05': 16}

temperatura_min = pd.Series(temperatura_minima)

temperatura_min.head()

temperatura_min.describe()

"""Ou até mesmo, acessar diretamente pelos índices"""

temperatura_min[['14/05','18/05','20/05','22/05']]

"""Ainda é possível buscar por posição, através do método iLoc"""

temperatura_min.iloc[0:3] #1º até 3º elemento

"""Podemos também usar o método Plot para gerar visualizacoes sobre os dados"""

temperatura_min.plot()

temperatura_min.plot(kind='bar')

"""## **Prática**

A partir do conjunto de dados de temperaturas mínimas do exemplo, junto ao conjunto de dados a seguir de temperaturas máximas, mais as regras de negócios fornecidas resolva a seguinte questão. Utilize Series Pandas e demais conhecimentos de python aprendidos.

Seu objetivo é ajudar um turista a planejar quais roupas deverá usar ou levar ao sair de casa para passar um dia inteiro de outono em Petrópolis, as regras são as seguintes:


*   **Casaco**: se a temperatura mínima do dia for menor que 16ºc
*   **Gorro**: se a temperatura mínima do dia for menor que a média de temperaturas mínimas
*   **Mochila**: quando a amplitude térmica for maior ou igual a 5ºc, será necessário levar uma mochila para guardar as roupas de frio
*   **Bermuda**: Se a temperatura máxima for pelo menos 22ºc e a mínima for acima das médias de temperaturas mínimas
*   **Luvas**: Se a temperatura mínima for a menor do período analisado


####*Amplitude Térmica*: Diferença entre a maior a menor temperatura em um período analisado. Nesse caso, estamos analisando por dia. (Máxima Dia - Mínima Dia)
####*Efeito Chuva*: Se chover, a sensação térmica ficará menor, com isso, todas as temperaturas serão consideradas 2ºc menores, tanto para máximas quanto para mínimas.


**Crie scripts para responder as seguintes questões**

1.   Se as temperaturas mínimas e máximas oscilarem 1ºc para cima em todos os dias, quantos dias o turista será recomendado a usar bermuda?
2.   Em quais dias será necessário levar mochila?
3.   Em algum dos dias o Turista será indicado a usar tanto bermuda quanto luvas?
4.   Quais serão os itens indicados para o dia 17/05?
5.   Em quais dias, que normalmente não necessitariam o uso de casaco, o item passaria a ser necessário em caso de chuva?
6.   Gere um gráfico com a evolução da amplitude térmica.
7.   Gere um gráfico que retorne quantas vezes cada item será utilizado.
"""

temperatura_max = {'13/05': 21,
                     '14/05': 20,
                     '15/05': 21,
                     '16/05': 22,
                     '17/05': 23,
                     '18/05': 22,
                     '19/05': 23,
                     '20/05': 23,
                     '21/05': 25,
                     '22/05': 25}

print(temperatura_max)

ler_base = pd.read_excel('./TempoMaio25.xlsx') # Ler o arquico XLSX em coluna organizada
print(ler_base)

import matplotlib.pyplot as plt

bermuda = ler_base['Bermuda'] # Quantidade de dias recomendados para usar bermuda - Questão 1
qtdBermuda = (bermuda == 1).sum()
print(str(qtdBermuda) + ' dias de uso de bermuda.')

mochila = ler_base['Mochila'] # Quantidade de dias recomendados para usar mochila - Questão 2
qtdMochila = (mochila == 1).sum()
print(str(qtdMochila) + ' dias de uso de mochila.')

luva = ler_base['Luvas'] # Quantidade de dias recomendados para usar luva
qtdLuva = (luva == 1).sum()
print(str(qtdLuva) + ' dias de uso de luvas.')

casaco = ler_base['Casaco'] # Quantidade de dias recomendados para usar casaco
qtdCasaco = (casaco == 1).sum()
print(str(qtdCasaco) + ' dias de uso de casaco.')

gorro = ler_base['Gorro'] # Quantidade de dias recomendados para usar gorro
qtdGorro = (gorro == 1).sum()
print(str(qtdGorro) + ' dias de uso de gorro.')

# Imprimir as datas que precisamos utilizar luvas e bermudas - Questão 3

data = ler_base['Data']
mask = (ler_base['Bermuda'] == 1) & (ler_base['Luvas'] == 1)

if mask.any():
    print(data[mask])
else:
    print('Não é necessário utilizar bermuda e luvas juntos.')

pecas = ler_base.loc[4, ['Casaco', 'Gorro', 'Mochila', 'Bermuda', 'Luvas']]
print(pecas)# Dados do dia 17/05 - Uso de Peças - Questão 4

# Questão 5 - Uso de casaco será necessário entre os dia 13 e 20 de maio,
#e somente choverá nos dias 15 e 16 de maio. Ou seja, faça sol ou chuva,
#o uso do casaco será necessário de acordo com as temperaturas.

amplitude_termica = ler_base['Amplitude_Termica']# Questão 6 - Gráfico em linha
data = ler_base['Data'].dt.strftime("%d/%m")
plt.plot(data, amplitude_termica)
plt.xlabel('Data')
plt.ylabel('Amplitude Térmica')
plt.title('Amplitude Térmica Diária')
plt.show()

amplitude_termica = ler_base['Amplitude_Termica']# Questão 6 - Gráfico em barras
data = ler_base['Data'].dt.strftime("%d/%m")
plt.bar(data, amplitude_termica)
plt.xlabel('Data')
plt.ylabel('Amplitude Térmica')
plt.title('Amplitude Térmica Diária')
plt.show()

itens = {
    'Roupas': ['Casaco', 'Gorro', 'Mochila', 'Bermuda', 'Luvas'],
    'Quantidade': [qtdCasaco, qtdGorro, qtdMochila, qtdBermuda, qtdLuva]
}
df_itens = pd.DataFrame(itens)
print(df_itens)
# Impressão de tabela das quantidades de itens usados - Questão 7

roupa = itens['Roupas']
quantidade = itens['Quantidade']

plt.plot(roupa, quantidade)
plt.xlabel('Roupas')
plt.ylabel('Quantidade')
plt.title('Uso Total de Cada Item')
plt.show()
#Gráfico em linhas - Questão 7

roupa = itens['Roupas']
quantidade = itens['Quantidade']

plt.bar(roupa, quantidade)
plt.xlabel('Roupas')
plt.ylabel('Quantidade')
plt.title('Uso Total de Cada Item')
plt.show()
#Gráfico em barras - Questão 7

# Explicações
import pandas as pd
import matplotlib.pyplot as plt

temperatura_minima = {'13/05': 13,
                     '14/05': 12,
                     '15/05': 15,
                     '16/05': 14,
                     '17/05': 14,
                     '18/05': 15,
                     '19/05': 14,
                     '20/05': 15,
                     '21/05': 16,
                     '22/05': 16}

temperatura_min = pd.Series(temperatura_minima)
temperatura_min.head()

temperatura_max = {'13/05': 21,
                     '14/05': 20,
                     '15/05': 21,
                     '16/05': 22,
                     '17/05': 23,
                     '18/05': 22,
                     '19/05': 23,
                     '20/05': 23,
                     '21/05': 25,
                     '22/05': 25}

# Assume temperatura_min and temperatura_max are defined as in the original notebook
# temperatura_min = pd.Series(...)
# temperatura_max = {'13/05': 21, ...}

# Convert temperatura_max dictionary to a pandas Series with the same index as temperatura_min
temperatura_max_series = pd.Series(temperatura_max, index=temperatura_min.index)
print(temperatura_max_series)

# Define the initial parts of the dictionary
tabela = {
    'dia':['13/05','14/05','15/05','16/05','17/05','18/05','19/05','20/05','21/05','22/05'],
    'minima': [13,12,15,14,14,15,14,15,16,16],
    'maxima': [21,20,21,22,23,22,23,23,25,25],
    'minima1': [13+1,12+1,15+1,14+1,14+1,15+1,14+1,15+1,16+1,16+1],
    'maxima1': [21+1,20+1,21+1,22+1,23+1,22+1,23+1,23+1,25+1,25+1], # Corrected key name
    # Create boolean Series directly from the conditions, explicitly aligning with the intended index length
    'casaco': (temperatura_min < 16).reset_index(drop=True),
    'gorro': (temperatura_min < temperatura_min.mean()).reset_index(drop=True),
    'mochila': ((temperatura_max_series - temperatura_min) >= 5).reset_index(drop=True),
    'luvas': (temperatura_min == temperatura_min.min()).reset_index(drop=True)
}

# Now that minima1 and maxima1 are defined within the dictionary, access them by key
# and use them to calculate the 'bermuda' boolean series.
# Ensure the Series used for calculation have the same length as other lists
tabela['bermuda'] = (pd.Series(tabela['maxima1']) >= 22) & (pd.Series(tabela['minima1']) > pd.Series(tabela['minima1']).min())

# Convert the dictionary 'tabela' into a pandas DataFrame, explicitly setting the index
df_tabela = pd.DataFrame(tabela).set_index('dia')

# Now you can call the .head() method on the DataFrame
print(df_tabela)

bermuda1 = tabela['bermuda'] # Quantidade de dias recomendados para usar bermuda - Questão 1
qtdBermuda1 = (bermuda1 == True).sum()
print(str(qtdBermuda1) + ' dias de uso de bermuda.')

mochila1 = tabela['mochila'] # Quantidade de dias recomendados para usar mochila - Questão 2
qtdMochila1 = (mochila1 == True).sum()
print(str(qtdMochila1) + ' dias de uso de mochila.')

luva1 = tabela['luvas'] # Quantidade de dias recomendados para usar luva
qtdLuva1 = (luva1 == True).sum()
print(str(qtdLuva1) + ' dias de uso de luvas.')

casaco1 = tabela['casaco'] # Quantidade de dias recomendados para usar casaco
qtdCasaco1 = (casaco1 == True).sum()
print(str(qtdCasaco1) + ' dias de uso de casaco.')

gorro1 = tabela['gorro'] # Quantidade de dias recomendados para usar gorro
qtdGorro1 = (gorro1 == True).sum()
print(str(qtdGorro1) + ' dias de uso de gorro.')

# Imprimir as datas que precisamos utilizar luvas e bermudas - Questão 3

data = tabela['dia']
mask = (tabela['bermuda'] == 1) & (tabela['luvas'] == 1)

if mask.any():
    print(data[mask])
else:
    print('Não é necessário utilizar bermuda e luvas juntos.')

#Questão 4

dia_buscado = '17/05'

resultados = {
    'casaco': bool(temperatura_min[dia_buscado]<16),
    'gorro': bool(temperatura_min[dia_buscado]<temperatura_min.mean()),
    'mochila': bool((temperatura_max[dia_buscado]-temperatura_min[dia_buscado])>=5),
    'bermuda': bool(temperatura_max[dia_buscado]>=22 and temperatura_min[dia_buscado] > temperatura_min.min()),
    'luvas': bool(temperatura_min[dia_buscado]==temperatura_min.min())
}

print(resultados)

# Questão 5 - Uso de casaco será necessário entre os dia 13 e 20 de maio,
#e somente choverá nos dias 15 e 16 de maio. Ou seja, faça sol ou chuva,
#o uso do casaco será necessário de acordo com as temperaturas.


# Define the initial parts of the dictionary
tabla = {
    'dia':['13/05','14/05','15/05','16/05','17/05','18/05','19/05','20/05','21/05','22/05'],
    'minima': [13,12,15-2,14-2,14,15,14,15,16,16],
    'maxima': [21,20,21-2,22-2,23,22,23,23,25,25],
    'minima1': [13+1,12+1,15+1-2,14+1-2,14+1,15+1,14+1,15+1,16+1,16+1],
    'maxima1': [21+1,20+1,21+1-2,22+1-2,23+1,22+1,23+1,23+1,25+1,25+1], # Corrected key name
    # Create boolean Series directly from the conditions, explicitly aligning with the intended index length
    'casaco': (temperatura_min < 16).reset_index(drop=True),
    'gorro': (temperatura_min < temperatura_min.mean()).reset_index(drop=True),
    'mochila': ((temperatura_max_series - temperatura_min) >= 5).reset_index(drop=True),
    'luvas': (temperatura_min == temperatura_min.min()).reset_index(drop=True)
}

# Now that minima1 and maxima1 are defined within the dictionary, access them by key
# and use them to calculate the 'bermuda' boolean series.
# Ensure the Series used for calculation have the same length as other lists
tabla['bermuda'] = (pd.Series(tabela['maxima1']) >= 22) & (pd.Series(tabela['minima1']) > pd.Series(tabela['minima1']).min())

# Convert the dictionary 'tabela' into a pandas DataFrame, explicitly setting the index
df_tabla = pd.DataFrame(tabla).set_index('dia')

# Now you can call the .head() method on the DataFrame
print(df_tabla)

amplitude_termica1 = temperatura_max_series - temperatura_min
# Questão 6 - Gráfico em linha
# Convert the list of date strings to a pandas Series of datetime objects
# The original list tabela['dia'] already contains the date strings in the desired format
data1 = tabela['dia']
plt.plot(data1, amplitude_termica1)
plt.xlabel('Data')
plt.ylabel('Amplitude Térmica')
plt.title('Amplitude Térmica Diária')
plt.show()

amplitude_termica1 = temperatura_max_series - temperatura_min
# Questão 6 - Gráfico em barra
# Convert the list of date strings to a pandas Series of datetime objects
# The original list tabela['dia'] already contains the date strings in the desired format
data1 = tabela['dia']
plt.bar(data1, amplitude_termica1)
plt.xlabel('Data')
plt.ylabel('Amplitude Térmica')
plt.title('Amplitude Térmica Diária')
plt.show()

itens1 = {
    'Roupas': ['Casaco', 'Gorro', 'Mochila', 'Bermuda', 'Luvas'],
    'Quantidade': [qtdCasaco, qtdGorro, qtdMochila, qtdBermuda, qtdLuva]
}
df_itens1 = pd.DataFrame(itens1)
print(df_itens1)
# Impressão de tabela das quantidades de itens usados - Questão 7

roupa1 = itens1['Roupas']
quantidade1 = itens1['Quantidade']

plt.plot(roupa1, quantidade1)
plt.xlabel('Roupas')
plt.ylabel('Quantidade')
plt.title('Uso Total de Cada Item')
plt.show()
#Gráfico em linhas - Questão 7

roupa1 = itens1['Roupas']
quantidade1 = itens1['Quantidade']

plt.bar(roupa1, quantidade1)
plt.xlabel('Roupas')
plt.ylabel('Quantidade')
plt.title('Uso Total de Cada Item')
plt.show()
#Gráfico em barras - Questão 7

"""# DataFrames

### Assim como nas seríes é possível usar as estruturas comuns da linguagem para a criação dos DataFrames. Também é possível importar de arquivos (txt, csv, excel, etc) ou da Web.
"""

#Campos: ID da Transação, Codigo Cliente, Modelo, Data do Aluguel, Data de Devolução, Valor Locacao, Taxa Administrativa

alugueis = [
    (1, 1023, "Onix", "2025-01-05", "2025-01-10", 1250.00, 150.00),
    (2, 1045, "HB20", "2025-01-07", "2025-01-12", 1400.00, 150.00),
    (3, 1102, "Tracker", "2025-01-10", "2025-01-15", 1750.50, 200.00),
    (4, 1150, "T-Cross", "2025-01-12", "2025-01-16", 1120.75, 200.00),
    (5, 1201, "Civic", "2025-01-15", "2025-01-17", 800.00, 250.00),
    (6, 1254, "Civic", "2025-01-18", "2025-01-31", 4525.25, 250.00),
    (7, 1300, "L200", "2025-01-20", "2025-01-29", 4875.00, 300.00),
    (8, 1356, "Compass", "2025-01-22", "2025-01-28", 3400.60, 400.00),
    (9, 1025, "Onix", "2025-02-01", "2025-02-05", 1000.00, 150.00),
    (10, 1023, "HB20", "2025-02-03", "2025-02-07", 1120.00, 150.00),
    (11, 1122, "Tracker", "2025-02-05", "2025-02-07", 425.75, 200.00),
    (12, 1177, "T-Cross", "2025-02-08", "2025-02-12", 1240.50, 200.00),
    (13, 1225, "Civic", "2025-02-10", "2025-02-15", 1750.00, 250.00),
    (14, 1270, "Civic", "2025-02-12", "2025-02-17", 2000.00, 250.00),
    (15, 1300, "L200", "2025-02-14", "2025-02-15", 500.00, 300.00),
    (16, 1375, "Compass", "2025-02-16", "2025-02-21", 3600.00, 400.00),
    (17, 1005, "Onix", "2025-02-18", "2025-02-19", 400.00, 150.00),
    (18, 1150, "Tracker", "2025-02-20", "2025-02-25", 1925.00, 250.00),
    (19, 1105, "T-Cross", "2025-02-22", "2025-02-26", 1300.00, 200.00),
    (20, 1023, "Civic", "2025-02-20", "2025-02-28", 3850.00, 250.00)
]

"""### Com isso, conseguimos instanciar a classe Dataframe, a partir da leitura do CSV. A partir de agora, os dados estão disponíveis para serem trabalhados em memória."""

df = pd.DataFrame(alugueis)

df.to_csv('alugueis_carros.csv', index= False, header = False)

df.tail()

df = pd.read_csv('alugueis_carros.csv',header=None)

display(df)

"""Podemos incluir o nome das colunas, já na criação do DataFrame"""

df = pd.DataFrame(alugueis, columns=[
    "id_transacao", "cod_cliente", "modelo", "data_aluguel", "data_devolucao", "valor_locacao", "taxa_administrativa"
])

df.head(10)

"""### Podemos utilizar alguns métodos para explorar e entender melhor o conjunto de dados."""

df.info()

df.describe()

df[['modelo','valor_locacao']].head(15)

"""### Mesmo em conjuntos de dados simples, podemos descobrir informações valiosas manipulando os dados."""

df.groupby('modelo')['valor_locacao'].mean()

"""Um tratamento comum de ser feito é a alteração de tipagens de dados"""

df['data_aluguel'] = pd.to_datetime(df['data_aluguel'], format='%Y-%m-%d')
df['data_devolucao'] = pd.to_datetime(df['data_devolucao'], format='%Y-%m-%d')

"""Podemos incluir a informação de duração prevista do aluguel"""

df['duracao_dias'] = (df['data_devolucao'] - df['data_aluguel']).dt.days

df.head(20)

df['valor_dia'] = (df['valor_locacao'] / df['duracao_dias']).round(2)

df.head()

df.groupby('modelo')['valor_dia'].mean().round(2)

"""## **Prática**

A partir do conteúdo apresentado sobre DataFrames, Séries e demais conhecimentos em Python. Utilize o conjunto de dados sobre locação veiculas abordado até aqui e responda as seguintes perguntas. Se necessário, faça tratamentos de manipulações no DataFrame.

### **Regras:**

**Classificação da duração do aluguel:**

*   **Curta** - Até 3 dias
*   **Média** - 4-7
*   **Longa** - Acima de 7 dias


**Valor Total:**

*   Soma do Total do Aluguel com a Taxa Administrativa

*Repare que o campo da Taxa Administrativa precisa ser tratado para poder ser utilizado como um campo numérico*

**Definição do Impacto das Taxas Administrativas na Composição do Preço:**

*   **Baixa** - Menos de 8% do Valor Total
*   **Média** - Entre 8% e 15% do Valor Total
*   **Alta** - Acima de 15% do Valor Total

**Desconto:**

*   Os descontos são aplicados após o cálculo do valor total. Existem 2 tipos de desconto, e eles são acumulativos.

1.   Desconto de Taxa: Caso a Classificação de Impacto das Taxas seja **Alta**, será ofertado um desconto que subtraído do valor da taxa, a deixe no patamar de 15%.
2.   Desconto de Duração: Será ofertado um desconto de **8%** para locações de duração **Média** e **12%** para locações de duração **Longa**.
3.   Desconto Total: Desconto de Duração + Desconto de Taxa.

*Formate com 2 casas decimais*

**Valor Final:**

*   Total - Desconto de Taxa - Desconto de Duração

**Percentual de Desconto:**

*   1 - (valor_final/valor_inicial)

*Formate com 1 casa decimal*

**Crie scripts para responder as seguintes questões**



1.    Qual é a proporção (%) de contratos curtos, médios e longos no período analisado?
2.   Quem são os três clientes (Código Cliente) que mais geraram receita total no período? Quanto (R$) cada um gastou?
3.   Calcule o total de desconto concedido pode modelo de carro.
4.   Ordene os aluguéis por % de desconto
5.   Calcule o Total de Diárias e o valor médio de diária por mês de aluguel (data_aluguel)
6.   Bônus: Exporte um Excel com todos os campos originais, além das informações enriquecidas: Classificador de Duração, Desconto Total, Valor Final e Percentual de Desconto.




---




"""

# Criação de colunas
df['ClassificacaoDuracao'] = df['duracao_dias'].apply(lambda x: 'Curta' if x <= 3 else ('Média' if 3 < x <= 7 else 'Longa'))
df['ValorTotal'] = (df['valor_locacao'] + df['taxa_administrativa']).round(2)
df['ClassificacaoTaxa'] = df.apply(lambda row: 'Baixa' if row['taxa_administrativa']/row['valor_locacao'] < 0.08 else ('Média' if 0.08 <= row['taxa_administrativa']/row['valor_locacao'] <= 0.15 else 'Alta'), axis=1)

df['DescontoTaxa'] = 0.0 # Initialize the column with 0
df.loc[df['ClassificacaoTaxa'] == 'Alta', 'DescontoTaxa'] = df['taxa_administrativa'] - (df['valor_locacao'] * 0.15) #Desconto de 15% para taxa classificada como alta

# Initialize the column with 0
df['DescontoDuracao'] = 0.0
df.loc[df['ClassificacaoDuracao'] == 'Longa', 'DescontoDuracao'] = df['valor_locacao'] * 0.12 #Duração de 12% para duração classificada como longa
df.loc[df['ClassificacaoDuracao'] == 'Média', 'DescontoDuracao'] = df['valor_locacao'] * 0.08 #Duração de 8% para duração classificada como média

#Conversão dos cálculos para 2 casas decimais
df['DescontoTaxa'] = (df['DescontoTaxa']).round(2)
df['DescontoDuracao'] = (df['DescontoDuracao']).round(2)
df['DescontoTotal'] = (df['DescontoTaxa'] + df['DescontoDuracao']).round(2)
df['ValorFinal'] = (df['ValorTotal'] - df['DescontoTotal']).round(2)

# Calculo de porcentagem
df['PercentualDesconto'] = ((df['DescontoTotal'] / df['ValorTotal'])*100).round(2)

df.head(20)

#Questão 1 - Porcentagem de Duração das Locações

curto = df['ClassificacaoDuracao'] == 'Curta'
ct = curto.sum()

medio = df['ClassificacaoDuracao'] == 'Média'
md = medio.sum()

longo = df['ClassificacaoDuracao'] == 'Longa'
lg = longo.sum()

total_dur = ct + md + lg

prazo_aluguel = {
    'Duração': ['Curto', 'Médio', 'Longo'],
    'Porcentagem': [str(ct/total_dur*100) + '%', str(md/total_dur*100) + '%', str(lg/total_dur*100) + '%']
}
df_prazo_aluguel = pd.DataFrame(prazo_aluguel)
df_prazo_aluguel.head()

prazo_aluguel = {
    'Duração': ['Curto', 'Médio', 'Longo'],
    'Porcentagem': [(ct/total_dur*100), (md/total_dur*100), (lg/total_dur*100)]
}
df_prazo_aluguel = pd.DataFrame(prazo_aluguel)
df_prazo_aluguel.plot(kind='pie',y='Porcentagem',xlabel='Duração')

# Questão 2 - Quem são os três clientes (Código Cliente) que mais geraram receita total no período? Quanto (R$) cada um gastou?

# Agrupar os 3 maiores clientes consumidores
top_clients = df.groupby('cod_cliente')['ValorTotal'].sum().sort_values(ascending=False).head(3)
print("Top 3 clientes por receita total:")
top_clients.head()

ModeloCarros = df['modelo'].unique()
print(ModeloCarros)

#Questão 3 - Somatório dos descontos por modelo de carros

DeOnix = df[df['modelo'] == 'Onix']['DescontoTotal'].sum()
DeHB20 = df[df['modelo'] == 'HB20']['DescontoTotal'].sum()
DeTracker = df[df['modelo'] == 'Tracker']['DescontoTotal'].sum()
DeTcross = df[df['modelo'] == 'T-Cross']['DescontoTotal'].sum()
DeCivic = df[df['modelo'] == 'Civic']['DescontoTotal'].sum()
DeL200 = df[df['modelo'] == 'L200']['DescontoTotal'].sum()
DeCompass = df[df['modelo'] == 'Compass']['DescontoTotal'].sum()

tabelmodels = {
    'Modelo': ['Onix', 'HB20', 'Tracker', 'T-Cross', 'Civic', 'L200', 'Compass'],
    'DescontoTotal': [DeOnix, DeHB20, DeTracker, DeTcross, DeCivic, DeL200, DeCompass]
}
df_tabelmodels = pd.DataFrame(tabelmodels)
df_tabelmodels.head(7)

# Questão 4 - Ordene os aluguéis por % de desconto indexados

percentual_sorted_df = df.sort_values(by='PercentualDesconto', ascending=False)
percentual = percentual_sorted_df['PercentualDesconto']
aluguel = percentual_sorted_df['ValorFinal']

table = {'%_Desconto': percentual, 'Aluguel': aluguel}
grade = pd.DataFrame(table)
grade.head(20)

#Questão 5 - Média de Diárias por mês

janeiro = df[df['data_aluguel'].dt.month == 1]
fevereiro = df[df['data_aluguel'].dt.month == 2]
janeiro_media = janeiro['ValorFinal'].mean().round(2)
fevereiro_media = fevereiro['ValorFinal'].mean().round(2)
qtjaneiro = janeiro['ValorFinal'].count()
qtfevereiro = fevereiro['ValorFinal'].count()

bimestre = {
    'Mês': ['Janeiro', 'Fevereiro'],
    'Média de Diárias': [janeiro_media, fevereiro_media],
    'Quantidade de Aluguéis': [qtjaneiro, qtfevereiro]
}
df_bimestre = pd.DataFrame(bimestre)
df_bimestre.head()

# Questão 6 - Planilha BÔNUS e suas edições para visualização quotidiana

df.to_excel('./alugueis_carros_BONUS.xlsx', index=False) #indexação da planilha anexada
bonus = pd.read_excel('./alugueis_carros_BONUS.xlsx') #Leitura da planilha

#Formatação das colunas do dataframe
bonus['data_aluguel'] = bonus['data_aluguel'].dt.strftime('%d/%m/%Y')
bonus['data_devolucao'] = bonus['data_devolucao'].dt.strftime('%d/%m/%Y')

bonus['valor_locacao'] = 'R$ '+ (bonus['valor_locacao'].round(2)).astype(str)
bonus['taxa_administrativa'] = 'R$ '+ (bonus['taxa_administrativa'].round(2)).astype(str)
bonus['valor_dia'] = 'R$ '+ (bonus['valor_dia'].round(2)).astype(str)
bonus['ValorTotal'] = 'R$ '+ (bonus['ValorTotal'].round(2)).astype(str)
bonus['duracao_dias'] = bonus['duracao_dias'].astype(str) + ' dias'
bonus['DescontoTaxa'] = 'R$ '+ (bonus['DescontoTaxa'].round(2)).astype(str)
bonus['DescontoDuracao'] = 'R$ '+ (bonus['DescontoDuracao'].round(2)).astype(str)
bonus['DescontoTotal'] = 'R$ '+ (bonus['DescontoTotal'].round(2)).astype(str)
bonus['ValorFinal'] = 'R$ '+ (bonus['ValorFinal'].round(2)).astype(str)

bonus['PercentualDesconto'] = bonus['PercentualDesconto'].astype(str).round(2) + '%'

bonus.head(20)